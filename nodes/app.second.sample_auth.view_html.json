{
  "name": "app.second.sample_auth.view_html",
  "type": "types.second.default.app",
  "data": {
    "html": "<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>Sample App</title>\n    <script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>\n    <script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script>\n    \n    <!-- Don't use this in production: -->\n    <script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"></script>\n    \n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/stellar-sdk/0.10.3/stellar-sdk.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js\"></script>\n    \n    <style>\n      .nodisplay {\n        display: none;\n      }\n    </style>\n    \n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"text/babel\">\n      \n      // check if logged in (has token in localstorage) \n      // - check validitity of token \n      // <input> field for username \n      // redirect to /grant page w/ grant request as object \n      // check for token on return (in window.location.hash)\n      // - save token to localStorage \n      \n      // if has token, button for making an authenticated request \n      // - test permissions and /ai request \n      \n      function parseQueryString( queryString ) {\n          var params = {}, queries, temp, i, l;\n          // Split into key/value pairs\n          queries = queryString.split(\"&\");\n          // Convert the array of strings into an object\n          for ( i = 0, l = queries.length; i < l; i++ ) {\n              temp = queries[i].split('=');\n              params[temp[0]] = temp[1];\n          }\n          return params;\n      };\n      \n      function encodeQueryData(data) {\n         const ret = [];\n         for (let d in data)\n           ret.push(encodeURIComponent(d) + '=' + encodeURIComponent(data[d]));\n         return ret.join('&');\n      }\n      \n      async function loadUsernameZonefile(username){\n        // nfkc, stellar details, \n        \n        var horizonPossible = {\n          public: {\n            name: 'PubNet',\n            address: 'https://horizon.stellar.org',\n            network: 'public'\n          },\n          test: {\n            name: 'TestNet',\n            address: 'https://horizon-testnet.stellar.org',\n            network: 'test'\n          }\n        };\n        \n        // load Route\n        // - get rid of \"/html\" or \"/view\"\n        var routeFullPath = username;\n        \n        if(routeFullPath.indexOf('test://') === 0){\n          // ok \n        } else if(routeFullPath.indexOf('test:') === 0){\n          // needs fix \n          routeFullPath = [routeFullPath.slice(0, 5), '//', routeFullPath.slice(5)].join('')\n        }\n        if(routeFullPath.indexOf('second://') === 0){\n          // ok \n        } else if(routeFullPath.indexOf('second:') === 0){\n          // needs fix \n          routeFullPath = [routeFullPath.slice(0, 7), '//', routeFullPath.slice(7)].join('')\n        }\n        \n        \n        if(routeFullPath.indexOf('://') === -1){\n          // Missing, default to public \n          routeFullPath = 'second://' + routeFullPath;\n        }\n        \n        var parser = window.document.createElement('a');\n        parser.href = routeFullPath; \n          \n        try {\n          var protocol = parser.protocol;\n          switch(protocol){\n            case 'id:':\n            case 'idtest:':\n            case 'test:':\n            case 'second:':\n              parser.protocol = 'http:';\n              break;\n            \n            default:\n              window.alert('Invalid protocol. please use id:// or idtest:// or second://');\n              throw \"invalid protocol\"\n          }\n          \n          var baseIdentity = parser.host;\n          var subname = parser.username || '';\n          var password = parser.password.length ? parser.password : '';\n          var routePath = ''; // zonefile at root! //parser.pathname || '/'; // parser.pathname ? parser.pathname.slice(1) : ''; // OLD removed leading slash! \n          \n          console.log('Parsed route:', {baseIdentity, subname, password, routePath});\n        \n          var stellarServer\n        \n          switch(protocol){\n            case 'id:':\n            case 'second:':\n              StellarSdk.Network.usePublicNetwork();\n              stellarServer = new StellarSdk.Server(horizonPossible['public'].address);\n              break;\n            case 'idtest:':\n            case 'test:':\n            case 'secondtest:':\n              StellarSdk.Network.useTestNetwork();\n              stellarServer = new StellarSdk.Server(horizonPossible['test'].address);\n              break;\n            default:\n              console.error('Invalid protocol');\n              throw \"invalid protocol\"\n          }\n          \n          console.log('stellarServer', stellarServer);\n          \n          // var usernameSeed = universe.crypto.createHash('sha256').update(baseIdentity).digest(); //returns a buffer\n          var baseIdentity = baseIdentity.normalize('NFKC').toLowerCase();\n          \n          console.log('baseIdentity:', baseIdentity);\n          \n          var usernameSeed = sha256.array(baseIdentity);\n          // NFK\n          console.log('usernameSeed', usernameSeed);\n          \n          var pairForIdentity = StellarSdk.Keypair.fromRawEd25519Seed(usernameSeed);\n          \n          console.log('pairForIdentity', pairForIdentity);\n          \n          \n          let identityAccount = await stellarServer.loadAccount(pairForIdentity.publicKey())\n            \n          \n          console.log('identityAccount:', identityAccount);\n          \n          // var lookupPath = subname + '|' + routePath;\n          // if(password){\n          //   lookupPath = password + '|' + subname + '|' + routePath;\n          //   // lookupPath = await encryptToString(subname + '|' + routePath, password+routePath)\n          // }\n          // var lookupPath = '/' + routePath;\n                \n          // route path ALWAYS starts with a slash \n          // - reserving non-slash for zone-like files \n          // if(routePath.length == 0){\n          //   routePath = '/';\n          // }\n          \n          var tmpQuerystring = window.location.search.substring(1);\n          var vars = tmpQuerystring.split('&');\n          var querystring = {};\n          for (var i = 0; i < vars.length; i++) {\n            var pair = vars[i].split('=');\n            querystring[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n          }\n          switch(querystring.slash){\n            case 0:\n            case '0':\n            case false:\n            case 'false':\n              routePath = routePath.slice(1);\n              break;\n            default:\n              break;\n          }\n          switch(querystring.root){\n            case 1:\n            case '1':\n            case true:\n            case 'true':\n              routePath = routePath.slice(1);\n              break;\n            default:\n              break;\n          }\n          \n          let lookupPath = baseIdentity + '|' + subname + '|' + password + '|' + routePath;\n          \n          // var lookupPathHash = universe.crypto.createHash('sha256').update(lookupPath).digest('hex'); \n           \n          console.log('lookupPath:', lookupPath); \n                           \n          var lookupPathHash = sha256.create().update(lookupPath).hex();\n          \n          console.log('lookupPathHash', lookupPathHash);\n          \n          \n          // get the ipfs value \n          let dataValue = await identityAccount.data({key: lookupPathHash})\n          console.log('dataValue', dataValue);\n          var valueIpfsHash = atob(dataValue.value);\n          \n          \n          console.log('Data Result:', valueIpfsHash);\n          if(!valueIpfsHash){\n            throw 'Missing data result'\n          }\n          \n          \n          // Load IPFS data \n          console.log('valueIpfsHash:', valueIpfsHash);\n          \n          let res = await window.fetch('https://ipfs.io/ipfs/' + valueIpfsHash);\n          let textResult = await res.text();\n          console.log('textResult:', textResult);\n          \n          // .then(function(res){\n          //   console.log('from IPFS.io:', res);\n          //   return res.text();\n          // })\n          // .then(function(textResult){\n          // })\n          // .catch(function(){\n          //   console.error('Failed loading IPFS hash from ipfs.io');\n          // })\n          \n          let zoneFile = JSON.parse(textResult);\n          \n          console.log('zoneFile:', zoneFile);\n          \n          if(zoneFile.type != 'types.second.default.user.hostfile'){\n            throw \"Invalid host zonefile\"\n          }\n          \n          return zoneFile;\n          \n          \n        }catch(err){\n          // failed finding route data \n          console.error('Failed search', err);\n        }\n        \n        return false;\n      }\n      \n      console.log('Hash:', window.location.hash);\n      \n      let hashQs = parseQueryString(window.location.hash.substring(1));\n      \n      console.log('hashQs:', hashQs);\n      \n      \n      let token,\n        authInfo;\n      \n      if(hashQs.token){\n        // set token \n        token = hashQs.token;\n        window.localStorage.setItem('token', token);\n        window.location = window.location.href.split('#')[0];\n      } else {\n        token = window.localStorage.getItem('token');\n        if(token){\n          try {\n            authInfo = window.localStorage.getItem('authInfo');\n            authInfo = JSON.parse(authInfo);\n          }catch(err){\n            console.error('failed loading authInfo:', err);\n            token = null;\n          }\n        }\n      }\n      \n      console.log('Auth Token:', token);\n      \n      \n      class App extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            token,\n            authInfo\n          }\n        }\n        render() { \n          return (\n            <div>\n              <h1>Sample App</h1>\n              {\n                this.state.token ? \n                  <Main />\n                :\n                  <Login />\n              }\n            </div>\n          ); \n        } \n      }\n      \n      class Login extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            username: ''\n          }\n        }\n        handleSubmit = async () => {\n          console.log('Trying login2');\n          \n          // build grant request \n          // - TODO: more fine-grained \n          let grantObj = {\n            redirect: window.location.href,\n          }\n          \n          console.log('grantObj', grantObj);\n\n          let qs = encodeQueryData(grantObj);\n          \n          // // save username to localStorage (grab on return) \n          // // - TODO: fetch via stellar, ipfs \n          \n          // let username = this.state.username;\n          \n          \n          // localStorage.setItem('username', username);\n          \n          // // TODO: \n          // // - load URL via Stellar \n          // // - also store publicKey \n          // let zoneFile = await loadUsernameZonefile(username);\n          // if(!zoneFile){\n          //   window.alert('Unable to load username zone file!', username);\n          //   return false;\n          // }\n          \n          // // console.log('zoneFile:', zoneFile);\n          // // return false;\n          \n          // let authInfo = {\n          //   username, // identity, also in zoneFile \n          //   zoneFile\n          // }\n          \n          // // example.com/auth/grant\n          // let url = `${zoneFile.data.urls.grant}?${qs}`;\n          \n          // TEMPORARY: hardcoded to local auth, NOT using username via chain \n          let authInfo = {\n            local: true\n          };\n          let url = `/auth/grant?${qs}`;\n          console.log('URL:', url);\n          \n          window.localStorage.setItem('authInfo', JSON.stringify(authInfo));\n          \n          // redirect to /grant page \n          window.location = url;\n          \n          return false;\n        }\n        render(){\n          return (\n            <div>\n              <input \n                type=\"text\" \n                placeholder=\"username\"\n                onChange={e=>this.setState({username:e.target.value})}\n                value={this.state.username}\n              />\n              <button onClick={this.handleSubmit}>\n                Login\n              </button>\n            </div>\n          )\n        }\n        \n      }\n      \n      class Main extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {}\n        }\n        handleLogout = () => {\n          window.localStorage.setItem('token', '');\n          window.location.reload();\n        }\n        render(){\n          return (\n            <div>\n              <h3>Logged In!</h3>\n              <a onClick={this.handleLogout}>logout</a>\n            </div>\n          )\n        }\n        \n      }\n      \n      \n      \n      ReactDOM.render(\n        <App />,\n        document.getElementById('root')\n      );\n\n    </script>\n    \n    \n  </body>\n</html>"
  },
  "blobdata": null,
  "createdAt": "2019-02-28T21:33:09.876Z",
  "updatedAt": "2019-02-28T21:46:06.072Z",
  "nodes": []
}